---
import '../styles/globals.css';

const API_BASE_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:8080';
const LOCATION_ID = import.meta.env.PUBLIC_LOCATION_ID || 'main';
const WEATHER_API_KEY = import.meta.env.PUBLIC_WEATHER_API_KEY || '';
const WEATHER_CITY = import.meta.env.PUBLIC_WEATHER_CITY || 'Buenos Aires,AR';
const SHOW_WEATHER = !!WEATHER_API_KEY;
const KIOSK_API_KEY = import.meta.env.PUBLIC_KIOSK_API_KEY || '';
---

<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="description" content="Pantalla p√∫blica de llamados - Sistema de Turnos PRO" />
    <title>Pantalla de Llamados</title>
    <script src="https://cdn.socket.io/4.8.3/socket.io.min.js" defer></script>
  </head>
  <body class="min-h-screen bg-gradient-to-br from-slate-900 via-indigo-900 to-purple-900 flex items-center justify-center p-4 md:p-8">
    <div id="screen-app" class="w-full max-w-6xl">
      <!-- Top Bar: Weather & Time -->
      <div class="flex justify-between items-center mb-8 px-2">
        <!-- Weather (only if API key is configured) -->
        {SHOW_WEATHER && (
          <div id="weather" class="flex items-center gap-3 bg-white/10 backdrop-blur-lg rounded-xl px-4 py-3 border border-white/20">
            <div id="weather-icon" class="text-3xl">üå§Ô∏è</div>
            <div>
              <div id="weather-temp" class="text-white font-bold text-xl">--¬∞C</div>
              <div id="weather-desc" class="text-white/80 text-sm">Cargando...</div>
            </div>
          </div>
        )}

        <!-- Time - Always visible, centered if no weather -->
        <div class={`bg-white/10 backdrop-blur-lg rounded-xl px-6 py-4 border border-white/20 text-center ${SHOW_WEATHER ? '' : 'mx-auto'}`}>
          <div id="current-time" class="text-white font-bold text-4xl md:text-5xl">--:--:--</div>
          <div id="current-date" class="text-white/80 text-base md:text-lg mt-2">--/--/----</div>
        </div>

        <!-- Spacer if weather is shown to balance layout -->
        {SHOW_WEATHER && <div class="w-[200px]"></div>}
      </div>

      <!-- Header -->
      <div class="text-center mb-10">
        <h1 class="text-5xl md:text-7xl font-bold text-white mb-3 drop-shadow-2xl">
          Sistema de Turnos
        </h1>
        <p class="text-xl md:text-2xl text-white/80">Pantalla de Llamados</p>
      </div>

      <!-- Current Call - Large & Prominent -->
      <div id="current-call" class="bg-gradient-to-r from-yellow-400 via-yellow-500 to-orange-500 rounded-3xl p-10 md:p-16 mb-8 border-4 border-yellow-300 text-center transition-all shadow-2xl">
        <div id="no-call" class="text-4xl md:text-5xl text-white font-semibold">
          ‚è≥ Esperando llamados...
        </div>
        <div id="call-content" class="hidden">
          <div class="text-3xl md:text-4xl text-white mb-6 font-semibold drop-shadow-lg">
            üéØ Ahora atendiendo en:
          </div>
          <div id="call-desk" class="text-6xl md:text-8xl font-black text-white mb-8 drop-shadow-2xl animate-bounce"></div>
          <div id="call-code" class="text-7xl md:text-9xl font-black text-slate-900 drop-shadow-2xl"></div>
          <div id="call-client-needs-data" class="hidden mt-6 px-6 py-4 bg-amber-600/90 text-white text-xl md:text-2xl font-semibold rounded-xl border-2 border-amber-700">
            üìã Este cliente debe completar sus datos antes de pedir un turno
          </div>
        </div>
      </div>

      <!-- Recent Calls -->
      <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 md:p-8 border-2 border-white/20">
        <h2 class="text-3xl md:text-4xl font-bold text-white mb-6 text-center">√öltimos Llamados</h2>
        <div id="recent-calls" class="space-y-4">
          <div class="text-center text-white/70 py-4 text-lg">No hay llamados recientes</div>
        </div>
      </div>
    </div>

    <script define:vars={{ apiBaseUrl: API_BASE_URL, locationId: LOCATION_ID, weatherApiKey: WEATHER_API_KEY, weatherCity: WEATHER_CITY, showWeather: SHOW_WEATHER, kioskApiKey: KIOSK_API_KEY }}>
      // Esperar a que Socket.io est√© disponible
      function waitForSocketIO(callback) {
        if (typeof io !== 'undefined') {
          callback();
        } else {
          console.log('‚è≥ Esperando Socket.io...');
          setTimeout(() => waitForSocketIO(callback), 100);
        }
      }

      // Audio context for sound
      let audioContext = null;
      
      // Initialize audio context
      function initAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
      }

      // Play notification sound
      function playNotificationSound() {
        if (!audioContext) initAudio();
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Create a pleasant beep sound
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1000, audioContext.currentTime + 0.1);
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
        
        // Play a second beep after a short delay
        setTimeout(() => {
          const oscillator2 = audioContext.createOscillator();
          const gainNode2 = audioContext.createGain();
          
          oscillator2.connect(gainNode2);
          gainNode2.connect(audioContext.destination);
          
          oscillator2.frequency.setValueAtTime(1000, audioContext.currentTime);
          oscillator2.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
          
          gainNode2.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          
          oscillator2.start(audioContext.currentTime);
          oscillator2.stop(audioContext.currentTime + 0.3);
        }, 200);
      }

      // Elements
      const weatherEl = showWeather ? document.getElementById('weather') : null;
      const weatherIconEl = showWeather ? document.getElementById('weather-icon') : null;
      const weatherTempEl = showWeather ? document.getElementById('weather-temp') : null;
      const weatherDescEl = showWeather ? document.getElementById('weather-desc') : null;
      const currentTimeEl = document.getElementById('current-time');
      const currentDateEl = document.getElementById('current-date');
      const currentCallEl = document.getElementById('current-call');
      const noCallEl = document.getElementById('no-call');
      const callContentEl = document.getElementById('call-content');
      const callDeskEl = document.getElementById('call-desk');
      const callCodeEl = document.getElementById('call-code');
      const callClientNeedsDataEl = document.getElementById('call-client-needs-data');
      const recentCallsEl = document.getElementById('recent-calls');

      let recentCalls = [];
      let currentCallTimeout = null;

      // Headers para peticiones al API (seguridad opcional)
      function getKioskHeaders() {
        const headers = { 'Content-Type': 'application/json' };
        if (kioskApiKey) headers['X-Kiosk-Key'] = kioskApiKey;
        return headers;
      }

      // Cargar estado de la pantalla al iniciar y al reconectar (persistencia al actualizar)
      async function fetchScreenState() {
        try {
          const url = `${apiBaseUrl}/queue/kiosk/screen?locationId=${encodeURIComponent(locationId)}`;
          const res = await fetch(url, { headers: getKioskHeaders() });
          if (!res.ok) return;
          const json = await res.json();
          const state = json.data;
          if (!state) return;

          if (state.currentCall) {
            if (noCallEl) noCallEl.classList.add('hidden');
            if (callContentEl) callContentEl.classList.remove('hidden');
            if (callDeskEl) callDeskEl.textContent = state.currentCall.deskId || 'VENT-?';
            if (callCodeEl) callCodeEl.textContent = state.currentCall.code;
            if (callClientNeedsDataEl) {
              if (state.currentCall.clientNeedsData) {
                callClientNeedsDataEl.classList.remove('hidden');
              } else {
                callClientNeedsDataEl.classList.add('hidden');
              }
            }
          } else {
            if (noCallEl) noCallEl.classList.remove('hidden');
            if (callContentEl) callContentEl.classList.add('hidden');
          }

          if (state.recentCalls && state.recentCalls.length > 0) {
            recentCalls = state.recentCalls.map((c) => ({
              code: c.code,
              deskId: c.deskId || 'VENT-?',
              calledAt: c.calledAt,
              isNew: false,
            }));
            updateRecentCalls();
          }
        } catch (err) {
          console.warn('No se pudo cargar estado de pantalla:', err);
        }
      }

      // Cargar estado al abrir la p√°gina (persistencia)
      fetchScreenState();

      // Update time
      function updateTime() {
        const now = new Date();
        const timeStr = now.toLocaleTimeString('es-AR', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false,
        });
        const dateStr = now.toLocaleDateString('es-AR', {
          weekday: 'long',
          day: '2-digit',
          month: 'long',
          year: 'numeric',
        });
        if (currentTimeEl) {
          currentTimeEl.textContent = timeStr;
        }
        if (currentDateEl) {
          currentDateEl.textContent = dateStr.charAt(0).toUpperCase() + dateStr.slice(1);
        }
      }

      updateTime();
      setInterval(updateTime, 1000);

      // Fetch weather (only if API key is configured)
      async function fetchWeather() {
        if (!showWeather || !weatherApiKey) return;

        try {
          const response = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?q=${weatherCity}&appid=${weatherApiKey}&units=metric&lang=es`
          );
          if (!response.ok) throw new Error('Weather API error');
          
          const data = await response.json();
          
          if (weatherTempEl) {
            weatherTempEl.textContent = `${Math.round(data.main.temp)}¬∞C`;
          }
          if (weatherDescEl) {
            weatherDescEl.textContent = data.weather[0].description.charAt(0).toUpperCase() + data.weather[0].description.slice(1);
          }
          if (weatherIconEl) {
            const iconCode = data.weather[0].icon;
            const iconMap = {
              '01d': '‚òÄÔ∏è', '01n': 'üåô',
              '02d': '‚õÖ', '02n': '‚òÅÔ∏è',
              '03d': '‚òÅÔ∏è', '03n': '‚òÅÔ∏è',
              '04d': '‚òÅÔ∏è', '04n': '‚òÅÔ∏è',
              '09d': 'üåßÔ∏è', '09n': 'üåßÔ∏è',
              '10d': 'üå¶Ô∏è', '10n': 'üå¶Ô∏è',
              '11d': '‚õàÔ∏è', '11n': '‚õàÔ∏è',
              '13d': '‚ùÑÔ∏è', '13n': '‚ùÑÔ∏è',
              '50d': 'üå´Ô∏è', '50n': 'üå´Ô∏è',
            };
            weatherIconEl.textContent = iconMap[iconCode] || 'üå§Ô∏è';
          }
        } catch (error) {
          console.error('Error fetching weather:', error);
          if (weatherDescEl) weatherDescEl.textContent = 'Error al cargar';
        }
      }

      // Fetch weather on load and every 30 minutes (only if configured)
      if (showWeather) {
        fetchWeather();
        setInterval(fetchWeather, 30 * 60 * 1000);
      }

      // Socket.io connection - esperar a que est√© disponible
      // Usar variable global para reconectar al volver a la pesta√±a (m√≥vil/sleep)
      let socketRef = null;

      waitForSocketIO(() => {
        console.log('üîå Conectando socket con:', {
          apiBaseUrl: apiBaseUrl,
          locationId: locationId,
        });

        // En m√≥vil: polling primero suele ser m√°s estable (websocket puede fallar al despertar)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const transports = isMobile ? ['polling', 'websocket'] : ['websocket', 'polling'];

        const socket = io(apiBaseUrl, {
          path: '/socket.io',
          query: {
            locationId: locationId,
          },
          transports,
          reconnection: true,
          reconnectionDelay: 1000,
          reconnectionDelayMax: 10000,
          reconnectionAttempts: Infinity,
          timeout: 20000,
        });
        socketRef = socket;

        // Al volver a la pesta√±a (ej. celular desbloqueado), forzar reconexi√≥n si est√° desconectado
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible' && socketRef && !socketRef.connected) {
            console.log('üîÑ Pesta√±a visible: reconectando socket...');
            socketRef.connect();
          }
        });

        // Socket events
        socket.on('connect', () => {
          console.log('‚úÖ Socket conectado', {
            socketId: socket.id,
            locationId: locationId,
            apiBaseUrl: apiBaseUrl,
          });
          fetchScreenState();
        });

        socket.on('disconnect', (reason) => {
          console.log('‚ùå Socket desconectado', reason);
        });

        socket.on('connect_error', (error) => {
          console.error('‚ùå Error de conexi√≥n Socket:', error);
        });

        // Escuchar todos los eventos para debugging (si est√° disponible)
        if (socket.onAny) {
          socket.onAny((eventName, ...args) => {
            console.log('üì° Evento recibido:', eventName, args);
          });
        }

        socket.on('queue:ticketCalled', (ticket) => {
          console.log('üé´ Ticket llamado:', ticket);
          
          // Play sound
          playNotificationSound();

          // Show current call
          if (noCallEl) noCallEl.classList.add('hidden');
          if (callContentEl) callContentEl.classList.remove('hidden');
          if (callDeskEl) callDeskEl.textContent = ticket.deskId || 'VENT-?';
          if (callCodeEl) callCodeEl.textContent = ticket.code;
          if (callClientNeedsDataEl) {
            if (ticket.clientNeedsData) {
              callClientNeedsDataEl.classList.remove('hidden');
            } else {
              callClientNeedsDataEl.classList.add('hidden');
            }
          }

          // Add to recent calls
          const newCall = {
            code: ticket.code,
            deskId: ticket.deskId || 'VENT-?',
            calledAt: ticket.calledAt || new Date().toISOString(),
            isNew: true, // Mark as new for animation
          };
          
          recentCalls.unshift(newCall);
          recentCalls = recentCalls.slice(0, 5); // Keep only 5
          updateRecentCalls();

          // Mark as not new after animation
          setTimeout(() => {
            if (recentCalls[0]) recentCalls[0].isNew = false;
            updateRecentCalls();
          }, 2000);

          // Clear current call after 30 seconds
          if (currentCallTimeout) {
            clearTimeout(currentCallTimeout);
          }
          currentCallTimeout = setTimeout(() => {
            if (noCallEl) noCallEl.classList.remove('hidden');
            if (callContentEl) callContentEl.classList.add('hidden');
            if (callClientNeedsDataEl) callClientNeedsDataEl.classList.add('hidden');
          }, 30000);

          // Pulse animation
          if (currentCallEl) {
            currentCallEl.classList.add('animate-pulse-scale');
            setTimeout(() => {
              if (currentCallEl) {
                currentCallEl.classList.remove('animate-pulse-scale');
              }
            }, 2000);
          }
        });

        socket.on('queue:ticketUpdated', (ticket) => {
          // If current ticket changed status, clear it
          if (callCodeEl && callCodeEl.textContent === ticket.code && ticket.status !== 'called') {
            if (noCallEl) noCallEl.classList.remove('hidden');
            if (callContentEl) callContentEl.classList.add('hidden');
          }
        });
      });

      function updateRecentCalls() {
        if (!recentCallsEl) return;

        if (recentCalls.length === 0) {
          recentCallsEl.innerHTML = '<div class="text-center text-white/70 py-4 text-lg">No hay llamados recientes</div>';
          return;
        }

        recentCallsEl.innerHTML = recentCalls
          .map((call, index) => {
            const time = new Date(call.calledAt).toLocaleTimeString('es-AR', {
              hour: '2-digit',
              minute: '2-digit',
            });
            
            // First one (most recent) is larger and highlighted
            const isFirst = index === 0;
            const sizeClass = isFirst 
              ? 'text-3xl md:text-4xl font-black' 
              : 'text-xl md:text-2xl font-bold';
            const bgClass = isFirst
              ? 'bg-gradient-to-r from-yellow-400/30 to-orange-400/30 border-2 border-yellow-400'
              : 'bg-white/5 border border-white/10';
            const animationClass = call.isNew && isFirst ? 'animate-slide-in' : '';
            
            return `
              <div class="flex justify-between items-center p-4 md:p-6 rounded-xl text-white ${bgClass} ${animationClass} transition-all">
                <span class="font-bold ${isFirst ? 'text-2xl md:text-3xl' : 'text-lg md:text-xl'}">${call.deskId}</span>
                <span class="${sizeClass} text-yellow-300 drop-shadow-lg">${call.code}</span>
                <span class="text-white/80 ${isFirst ? 'text-lg' : 'text-sm'}">${time}</span>
              </div>
            `;
          })
          .join('');
      }
    </script>

    <style>
      @keyframes pulse-scale {
        0%, 100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }
      
      @keyframes slide-in {
        0% {
          transform: translateX(-100%);
          opacity: 0;
        }
        100% {
          transform: translateX(0);
          opacity: 1;
        }
      }
      
      @keyframes bounce {
        0%, 100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-10px);
        }
      }
      
      .animate-pulse-scale {
        animation: pulse-scale 2s ease-in-out;
      }
      
      .animate-slide-in {
        animation: slide-in 0.5s ease-out;
      }
      
      .animate-bounce {
        animation: bounce 1s infinite;
      }
    </style>
  </body>
</html>
